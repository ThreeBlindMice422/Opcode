*-----------------------------------------------------------
* Title      : Opcode Disassembler
* Written by : Hao-Han Chao 
* Date       : 03/06/2016
* Description: Move & ADD & ADDA & MOVEQ & CMP & ADDI & BCC &
*               & DIVU & MULS.W & AND & SUB & LSL & ASR & ROL
*               & RTS & NOP & CLR & MOVEM & JSR & LEA
*-----------------------------------------------------------
       
*****************************************
*
* Disassembler code starts here
*
*****************************************
            ORG     $1000
START:         
            
            LEA     WELCOME,A1 
            MOVE.B  #14,D0
            TRAP    #15 ; display welcome
            BRA     INPUT_HANDLER
    
INPUT_HANDLER:                  

            LEA     PROMPTST,A1 
            MOVE.B  #14,D0
            TRAP    #15 ; display st address prompt
    
            LEA     ADDR_BUFFER,A1
            MOVE.B  #2,D0
            TRAP    #15 ; read starting address as ascii. stores it in (A1) as a buffer. 
                        ; length gets stored in D1
    
            ; can check for invalid length first
            ; address must be between $0 and $FFFFFF (highest 6-digit) inclusive
            CMP.B   #0,D1
            BLE     INVALID
            CMP.B   #7,D1
            BGE     INVALID
    
            ; temporarily store string length value in D2
            ; and store address in A2 (D1, A1 for use in LOOP later)
            MOVE.B  D1,D2
            MOVEA.W A1,A2
            ; check for invalid characters
            BRA     CHECKLOOP
        
CLEARED: ; address is valid
            CLR.L   D0
            BRA     LOOP ; go to conversion loop

ENDLOOP:    
    
            CLR.L   D0
    
            LEA     PROMPTEND,A1 
            MOVE.B  #14,D0
            TRAP    #15 ; display end address prompt
    
            LEA     ADDR_BUFFER,A1
            MOVE.B  #2,D0
            TRAP    #15 ; read starting address as ascii. stores it in (A1) as a buffer. 
                        ; length gets stored in D1


            ; can check for invalid length first
            ; address must be between $0 and $FFFFFF (highest 6-digit) inclusive
            CMP.B   #0,D1
            BLE     INVALID
            CMP.B   #7,D1
            BGE     INVALID

            ; temporarily store string length value in D2
            ; and store address in A2 (D1, A1 for use in LOOP later)
            MOVE.B  D1,D2
            MOVEA.W A1,A2
            ; check for invalid characters
            BRA     CHECKLOOP

SEND_ADDR: ; gets called after conversion loop. puts the address value in memory.
            CMPA.L   #$00000000,A3 ; if A3 (soon to be the input address) is already filled,
                                   ; go to SEND_END_ADDR instead 
            BNE     SEND_END_ADDR
            MOVEA.L  D0,A3
            BRA ENDLOOP
SEND_END_ADDR:
            MOVEA.L D0,A4 ; A4 is ending address
            CMPA.L  A4,A3
            BGT     INVALID ; starting addr > ending addr
            MOVE.L  A3,START_ADDR 
            MOVE.L  A4,END_ADDR
            BRA OP    
    
INVALID:
            LEA     INVALID_MSG,A1
            MOVE.B  #14,D0
            TRAP    #15 ; display error message
            CMPA.L  #$00000000,A3
            BNE     ENDLOOP ; if 1st addr is already filled, goto second input loop
            BRA     INPUT_HANDLER ; go back to starting prompt
    
CHECKLOOP: ; loop that checks for invalid characters in an address
            CMPI.B  #$47,(A2) ; checks if character is over 'F'
            BGE     INVALID
            CMPI.B  #$2F,(A2)+ ; checks if character is under '0'
            BLE     INVALID
            SUBI.B  #1,D2
            CMPI.B  #0,D2
            BEQ     CLEARED ; reached end of string, no errors
            BRA     CHECKLOOP
LOOP: ; conversion loop
            CMPI.B  #$41,(A1)
            BGE     TEN_OR_HIGHER
            CMPI.B  #$39,(A1)
            BLE     NINE_OR_LESS
CONT:    
            OR.B    (A1)+,D0 ; add byte value to D0, move A1 to next byte

            SUBI.B  #1,D1 ; decrement D1, which holds # of chars in input
            CMPI.B  #0,D1 ; check if D1 reached 0. if so, end of iteration
            BEQ     SEND_ADDR
    
            ASL.L   #4,D0 ; shift hex digit in D0 left
    
            BRA     LOOP 
    
TEN_OR_HIGHER:
            SUB.B   #55,(A1)  ; get hex value for char, store in A1
            JMP     CONT
NINE_OR_LESS:
            SUB.B   #48,(A1)  ; get hex value for number, store in A1
            JMP     CONT
;------------------------------OPCODE-------------------------------------------  
OP       
while_loop  
            ;MOVE.L  END_ADDR, D7    * Loads ending address to D7
            ;CMP.L   START_ADDR, D7  * Compare ending adress to staring address
            ;BLE     EA              * branches to EA if less or equal
            
            CLR.L   D7              * Clear 
            MOVEA.L START_ADDR,A1   * Loads the address to A1
            LEA     BUFFER,A2       * Loads buffer to A2
            
            MOVE.W  (A1),D7         * Move the insturction into D7
            LEA     stack,SP        * Load the SP = A7 which is stack pointer                          
            LEA     op_jmp_table,A0 * Index into the table
            CLR.L   D0              * Clear
            CLR.L   D1              * Clear 
            MOVE.W  D7,D0           * Put instruction into D0
            MOVE.B  #shift,D1       * Put shift constant into D1
            LSR.W   D1,D0           * Logical shift right 12 bits
        
            MULU    #6,D0           * Multiply D0 by 6
                                    * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)        * Jump indirect with index
                                    * JSR stores the return location into the stack
                                    * so the 68k can return back to the JSR, and continue
            ;ADD.L    #2, START_ADDR
            
            ; Trap tast 15 use for testing
            ; output Source and Destination EA
            ;----------------------------------------------------------
            ;CLR.L     D1                   ; Clear D1
            ;CLR.L     D2                   ; Clear D2
            ;MOVE.B    EA_SOURCE, D1        ; Put Carry into D1
            ;MOVEQ     #16,D2
            ;MOVE.B    #15,D0
            ;TRAP      #15                  ; Output as a decimal number
            
            ;CLR.L     D1                   ; Clear D1
            ;CLR.L     D2                   ; Clear D2
            ;MOVE.B    EA_DEST, D1            ; Put Carry into D1
            ;MOVEQ     #16,D2
            ;MOVE.B    #15,D0
            ;TRAP      #15                  ; Output as a decimal number
            ;----------------------------------------------------------
                         
            ;BRA while_loop
      
EA          MOVE.B  #9, D0
            TRAP    #15                 ; halt simulator
            
*-----------------------CLR & JSR & RTS & NOP & LEA & MOVEM TABLE---------
c0100_jum_tab JMP j_clr_b
            JMP j_rts_nop_clr_w
            JMP j_movem_w_jsr_clr_l
            JMP j_movem_l
            JMP j_0100_100
            JMP j_0100_101
            JMP j_0100_110
            JMP j_lea

j_clr_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CLR_B,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$434C522E,(A2)+   ; Push CLR. into buffer
            MOVE.W  #$427F,(A2)+       ; Push B space into buffer
               
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_rts_nop_clr_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     nop_clr_w_rts_jmp_tab,A0   * Index into the table
            CLR.L   D0                * Clear
            MOVE.W  D7,D0             * Put instruction into D0
            AND.W   #$0600,D0         * Mask the condition bits
            MOVE.B  #9,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 9 bits
                                      * get 0000 0000 0000 00[10bit][9bit]
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue

            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6            
            RTS         
j_movem_w_jsr_clr_l 
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     movem_w_jsr_clr_L_tab,A0   * Index into the table
            CLR.L   D0                * Clear
            MOVE.W  D7,D0             * Put instruction into D0
            AND.W   #$0600,D0         * Mask the condition bits
            MOVE.B  #9,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 9 bits
                                      * get 0000 0000 0000 00[10bit][9bit]
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue

            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS    
j_movem_l   
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVEM_L,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message   
            
            MOVE.L  #$4D4F5645,(A2)+   ; Push MOVE into buffer
            MOVE.L  #$4D2E4C7F,(A2)+   ; Push M.L SAPCE space into buffer
            
            LEA     movem_l_reg_mem_tab,A0   * Index into the table
            CLR.L   D0                * Clear
            MOVE.W  D7,D0             * Put instruction into D0
            AND.W   #$0400,D0         * Mask the condition bits
            MOVE.B  #10,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 9 bits
                                      * get 0000 0000 0000 00[10bit][9bit]
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
             
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_0100_100  STOP    #$2700
j_0100_101  STOP    #$2700
j_0100_110  STOP    #$2700
j_lea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     LEA,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$4C45417F,(A2)+   ; Push LEA SPACE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
*-----------------------NOP & CLR.W & RTS TABLE------------------------------
nop_clr_w_rts_jmp_tab JMP j_nop_clr_rts_00
            JMP j_clr_w
            JMP j_nop_clr_rts_10
            JMP j_rts_nop

j_nop_clr_rts_00    STOP    #$2700
j_clr_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CLR_W,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message   
            
            MOVE.L  #$434C522E,(A2)+   ; Push CLR. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer 
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS     
j_nop_clr_rts_10    STOP    #$2700
j_rts_nop
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     nop_rts_jmp_tab,A0   * Index into the table
            CLR.L   D0                * Clear
            MOVE.W  D7,D0             * Put instruction into D0
            AND.W   #$0004,D0         * Mask the condition bits
            MOVE.B  #2,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 2 bits
                                      * get 0000 0000 0000 000[2bit]
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS  

*-----------------------NOP & RTS TABLE--------------------------------------
nop_rts_jmp_tab JMP j_nop
            JMP j_rts 
j_nop
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     NOP,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15             * display the message   
                
            MOVE.L  #$4E4F507F,(A2)+   ; Push NOP SPACE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS    
j_rts 
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     RTS,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15             * display the message    
            
            MOVE.L  #$5254537F,(A2)+   ; Push RTS SPACE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS    

*-----------------------MOVEM.W & JSR & CLR.L TABLE---------------------------
movem_w_jsr_clr_L_tab JMP j_movem_w_reg_mem
            JMP j_clr_l
            JMP j_movem_w_mem_reg
            JMP j_jsr
j_movem_w_reg_mem  
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVEM_W,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$4D4F5645,(A2)+   ; Push MOVE into buffer
            MOVE.L  #$4D2E577F,(A2)+   ; Push M.W SAPCE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_clr_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CLR_L,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$434C522E,(A2)+   ; Push CLR. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_movem_w_mem_reg   
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVEM_W,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message   
            
            MOVE.L  #$4D4F5645,(A2)+   ; Push MOVE into buffer
            MOVE.L  #$4D2E577F,(A2)+   ; Push M.W SAPCE into buffer 
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS 
j_jsr
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     JSR,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$4A53527F,(A2)+   ; Push JSR SAPCE into buffer
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

*-----------------------MOVEM.L_REG->MEM & MOVEM.L_MEM->REG TABLE----------------
movem_l_reg_mem_tab JMP j_movem_l_reg_mem
            JMP j_movem_l_mem_reg
j_movem_l_reg_mem 
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                                    
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_movem_l_mem_reg 
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                                    
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
*-----------------------ASR & LSL & ROL TABLE-----------------------------
reg_mem_jum_tab JMP j_reg_b
            JMP j_reg_w
            JMP j_reg_l
            JMP j_mem
            
j_reg_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            MOVE.W      D7,D0
            LEA     reg_b_jum_tab,A0  * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            AND.L   #$0118,D0         * get 0000 0001 0001 1000 bits
            MOVE.B  #3,D1             * Put shift constant into D1
            LSL.B   D1,D0             * Logical shift left 3 bits
        
            MOVE.B  #6,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 6 bits
                                      * get 0000 0000 0000 0[dr][3bit][4bit]
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

j_reg_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            MOVE.W      D7,D0
            LEA     reg_w_jum_tab,A0  * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            AND.L   #$0118,D0         * get 0000 0001 0001 1000 bits
            MOVE.B  #3,D1             * Put shift constant into D1
            LSL.B   D1,D0             * Logical shift left 3 bits
        
            MOVE.B  #6,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 6 bits
                                      * get 0000 0000 0000 0[dr][3bit][4bit]
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_reg_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            MOVE.W      D7,D0
            LEA     reg_l_jum_tab,A0  * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            AND.L   #$0118,D0         * get 0000 0001 0001 1000 bits
            MOVE.B  #3,D1             * Put shift constant into D1
            LSL.B   D1,D0             * Logical shift left 3 bits
        
            MOVE.B  #6,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 6 bits
                                      * get 0000 0000 0000 0[dr][3bit][4bit]
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_mem
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            MOVE.W      D7,D0
            LEA     mem_jum_tab,A0  * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            AND.L   #$0700,D0         * get 0000 0001 0001 1000 bits
        
            MOVE.B  #8,D1             * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 8 bits
                                      * get 0000 0000 0000 0[10bit][9bit][dr]
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

*-----------------------ASR & LSL & ROL Register Byte size shift TABLE-------------------
reg_b_jum_tab   JMP j_asr_b
                JMP j_reg_b_001
                JMP j_reg_b_010
                JMP j_reg_b_011
                JMP j_reg_b_100
                JMP j_lsl_b
                JMP j_reg_b_110
                JMP j_rol_b

j_asr_b 
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ASR_B,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message 

                MOVE.L  #$4153522E,(A2)+   ; Push ASR. into buffer
                MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer   
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_b_001     STOP    #$2700
j_reg_b_010     STOP    #$2700
j_reg_b_011     STOP    #$2700
j_reg_b_100     STOP    #$2700
j_lsl_b
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     LSL_B,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message   
                
                MOVE.L  #$4C534C2E,(A2)+   ; Push LSL. into buffer
                MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer 
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_b_110     STOP    #$2700
j_rol_b
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ROL_B,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message  

                MOVE.L  #$524F4C2E,(A2)+   ; Push ROL. into buffer
                MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS

*-----------------------ASR & LSL & ROL Register Word size shift TABLE--------------------              
reg_w_jum_tab   JMP j_asr_w
                JMP j_reg_w_001
                JMP j_reg_w_010
                JMP j_reg_w_011
                JMP j_reg_w_100
                JMP j_lsl_w
                JMP j_reg_w_110
                JMP j_rol_w

j_asr_w
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ASR_W,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message  
                
                MOVE.L  #$4153522E,(A2)+   ; Push ASR. into buffer
                MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_w_001     STOP    #$2700
j_reg_w_010     STOP    #$2700
j_reg_w_011     STOP    #$2700
j_reg_w_100     STOP    #$2700
j_lsl_w
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     LSL_W,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message  

                MOVE.L  #$4C534C2E,(A2)+   ; Push LSL. into buffer
                MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_w_110     STOP    #$2700
j_rol_w
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ROL_W,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message  

                MOVE.L  #$524F4C2E,(A2)+   ; Push ROL. into buffer
                MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
*-----------------------ASR & LSL & ROL Regsiter Long size shift TABLE----------------------   
reg_l_jum_tab   JMP j_asr_l
                JMP j_reg_l_001
                JMP j_reg_l_010
                JMP j_reg_l_011
                JMP j_reg_l_100
                JMP j_lsl_l
                JMP j_reg_l_110
                JMP j_rol_l

j_asr_l
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ASR_L,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message    
                
                MOVE.L  #$4153522E,(A2)+   ; Push ASR. into buffer
                MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_l_001     STOP    #$2700
j_reg_l_010     STOP    #$2700
j_reg_l_011     STOP    #$2700
j_reg_l_100     STOP    #$2700
j_lsl_l
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     LSL_L,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message 

                MOVE.L  #$4C534C2E,(A2)+   ; Push LSL. into buffer
                MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer   
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_reg_l_110     STOP    #$2700
j_rol_l
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ROL_L,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message 

                MOVE.L  #$524F4C2E,(A2)+   ; Push ROL. into buffer
                MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer     
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
*-----------------------ASR & LSL & ROL memory shift TABLE-----------------------------                
mem_jum_tab     JMP j_asr
                JMP j_mem_001
                JMP j_mem_010
                JMP j_lsl
                JMP j_mem_100
                JMP j_mem_101
                JMP j_mem_110
                JMP j_rol

j_asr   
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ASR,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message    
                
                MOVE.L  #$4153527F,(A2)+   ; Push ASR SAPCE into buffer
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_mem_001       STOP    #$2700
j_mem_010       STOP    #$2700
j_lsl   
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     LSL,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message 
        
                MOVE.L  #$4C534C7F,(A2)+   ; Push LSL SPACE into buffer   
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
j_mem_100       STOP    #$2700
j_mem_101       STOP    #$2700
j_mem_110       STOP    #$2700
j_rol
                MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
                LEA     ROL,A1          * loads string to A1
                MOVE.B  #14,D0
                TRAP    #15                * display the message    
                
                MOVE.L  #$524F4C7F,(A2)+   ; Push ROL SAPCE into buffer  
                           
                MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
                RTS
*-----------------------AND & MULS.W JUMP TABLE-----------------------------
and_jmp_tab JMP     j_and_b             * AND & MULS.W jump table
            JMP     j_and_w
            JMP     j_and_l
            JMP     c0011
            JMP     j_and_b_d_ea
            JMP     j_and_w_d_ea
            JMP     j_and_l_d_ea
            JMP     j_muls_w
j_and_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer   
            
            * AND <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_and_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
            
            * AND <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_and_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer  
            
            * AND <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
c0011    STOP    #$2700
j_and_b_d_ea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
            
            * AND Dn, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_and_w_d_ea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
            
            * AND Dn, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_and_l_d_ea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     AND_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$414E442E,(A2)+   ; Push AND. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer  
            
            * AND Dn, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_muls_w      
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MULS_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4D554C53,(A2)+   ; Push MULS into buffer
            MOVE.W  #$2E57,(A2)+   ; Push .W into buffer  
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer
            
            * CMP <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

*-----------------------ADDI JUMP TABLE-----------------------------        
addi_jmp_tab JMP     j_addi_b             * ADDI jump table
            JMP     j_addi_w
            JMP     j_addi_l
j_addi_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADDI_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                  * display the message
            
            MOVE.L  #$41444449,(A2)+   ; Push ADDI into buffer
            MOVE.W  #$2E42,(A2)+   ; Push .B into buffer  
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer
            
            * ADDI #<data>, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_addi_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADDI_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                  * display the message
            
            MOVE.L  #$41444449,(A2)+   ; Push ADDI into buffer
            MOVE.W  #$2E57,(A2)+   ; Push .W into buffer  
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer
            
             * ADDI #<data>, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_addi_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADDI_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                  * display the message
            
            MOVE.L  #$41444449,(A2)+   ; Push ADDI into buffer
            MOVE.W  #$2E4C,(A2)+   ; Push .L into buffer  
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer
            
             * ADDI #<data>, <ea>
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
        
*-----------------------CMP JUMP TABLE-----------------------------
cmp_jmp_tab JMP     j_cmp_b             * CMP jump table
            JMP     j_cmp_w
            JMP     j_cmp_l
j_cmp_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CMP_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$434D502E,(A2)+   ; Push CMP. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
            
            * CMP <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_cmp_w
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CMP_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$434D502E,(A2)+   ; Push CMP. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
            
            * CMP <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_cmp_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     CMP_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$434D502E,(A2)+   ; Push CMP. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer  
            
            * CMP <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
*-----------------------SUB JUMP TABLE-----------------------------
sub_jmp_tab JMP     j_sub_b             * SUB jump table
            JMP     j_sub_w
            JMP     j_sub_l
            JMP     code011
            JMP     j_sub_b_d_ea
            JMP     j_sub_w_d_ea
            JMP     j_sub_l_d_ea

j_sub_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
            
            ; SUB <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
j_sub_w       
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
            
            ; SUB <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_sub_l         
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer  
            
            ; SUB <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
code011     STOP    #$2700
j_sub_b_d_ea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
            
            ; SUB Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
j_sub_w_d_ea       
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer  
            
            ; SUB Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_sub_l_d_ea         
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     SUB_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$5355422E,(A2)+   ; Push SUB. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer  
            
            ; SUB Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS


*-----------------------ADD & ADDA JUMP TABLE-----------------------------
add_jmp_tab JMP     j_add_b             * ADD & ADDA jump table
            JMP     j_add_w
            JMP     j_add_l
            JMP     j_adda_w
            JMP     j_add_b_d_ea
            JMP     j_add_w_d_ea
            JMP     j_add_l_d_ea
            JMP     j_adda_l
                              
j_add_b
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer  
            
            ; ADD <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
j_add_w       
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer 
            
            ; ADD <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_add_l         
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer 
            
            ; ADD <ea>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_adda_w         
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADDA_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$41444441,(A2)+   ; Push ADDA into buffer
            MOVE.W  #$2E57,(A2)+   ; Push .W into buffer 
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer 
            
            ; ADDA <ea>, An           
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS   
j_add_b_d_ea
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_B,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$427F,(A2)+   ; Push B SAPCE into buffer 
            
            ; ADD Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
j_add_w_d_ea       
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_W,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$577F,(A2)+   ; Push W SAPCE into buffer 
            
            ; ADD Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_add_l_d_ea         
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADD_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4144442E,(A2)+   ; Push ADD. into buffer
            MOVE.W  #$4C7F,(A2)+   ; Push L SAPCE into buffer 
            
            ; ADD Dn, <ea>                            
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_adda_l
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     ADDA_L,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$41444441,(A2)+   ; Push ADDA into buffer
            MOVE.W  #$2E4C,(A2)+   ; Push .L into buffer 
            MOVE.B  #$7F,(A2)+   ; Push SAPCE into buffer 
            
            ; ADDA <ea>, An
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

*-----------------------BCC JUMP TABLE-----------------------------
bcc_jmp_tab JMP   j_bcc
           JMP   code01
           JMP   j_bgt
           JMP   j_ble

j_bcc   
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     BCC,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15               * display the message
            
            MOVE.L  #$4243437F,(A2)+   ; Push BCC SAPCE into buffer
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
code01      STOP    #$2700
j_bgt
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     BGT,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15               * display the message
            
            MOVE.L  #$4247547F,(A2)+   ; Push BGT SPACE into buffer
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
j_ble
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     BLE,A1            * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15               * display the message
            
            MOVE.L  #$424C457F,(A2)+   ; Push BLE SAPCE into buffer
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
 
*-----------------------OPCODE JUMP TABLE-----------------------------
op_jmp_table JMP     code0000
            JMP     code0001
            JMP     code0010
            JMP     code0011
            JMP     code0100
            JMP     code0101
            JMP     code0110
            JMP     code0111
            JMP     code1000
            JMP     code1001
            JMP     code1010
            JMP     code1011
            JMP     code1100
            JMP     code1101
            JMP     code1110
            JMP     code1111
            
code0000    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     addi_jmp_tab,A0    * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #8,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #14,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift left 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
code0001
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVE_B,A1          * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                * display the message    
            
            MOVE.L  #$4D4F5645,(A2)+   * Push MOVE into buffer
            MOVE.W  #$2E42,(A2)+       ; Push .B into buffer
            MOVE.B  #$7F,(A2)+         ; Push sapce into buffer         
            
            * MOVE <ea>,<ea>
                           
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
code0010    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVE_L,A1           * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
                      
            MOVE.L  #$4D4F5645,(A2)+    ; Push MOVE into buffer
            MOVE.W  #$2E4C,(A2)+        ; Push .L into buffer
            MOVE.B  #$7F,(A2)+          ; Push Space into buffer
            
            * MOVE <ea>,<ea>        
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

code0011    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVE_W,A1           * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4D4F5645,(A2)+    ; Push MOVE into buffer
            MOVE.W  #$2E57,(A2)+        ; Push .W into buffer
            MOVE.B  #$7F,(A2)+          ; Push Space into buffer
            
            * MOVE <ea>,<ea>          
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
code0100     
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     c0100_jum_tab,A0    * Index into the table
            CLR.L   D0                  * Clear
            MOVE.W  D7,D0               * Put instruction into D0
            AND.W   #$01C0,D0           * Mask the condition bits
            LSR.W   #6,D0               * Logical shift right 6 bits
            
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue

            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS          
code0101    STOP    #$2700
code0110   
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     bcc_jmp_tab,A0    * Index into the table
            CLR.L   D0                  * Clear
            MOVE.W  D7,D0               * Put instruction into D0
            AND.W   #$0300,D0           * Mask the condition bits
            LSR.W   #8,D0               * Logical shift right 8 bits
            
            MULU    #6,D0
            
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue

            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS       
code0111    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     MOVEQ,A1           * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$4D4F5645,(A2)+    ; Push MOVE into buffer
            MOVE.W  #$517F,(A2)+        ; Push Q SPACE into buffer
            
            * MOVEQ #<data>, Dn
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS            
            
code1000    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)
            LEA     DIVU,A1           * loads string to A1
            MOVE.B  #14,D0
            TRAP    #15                 * display the message
            
            MOVE.L  #$44495655,(A2)+    ; Push DIVU into buffer
            MOVE.B  #$7F,(A2)+          ; Push Space into buffer
            
            * DIVU.W < ea > ,Dn32/16 -> 16r -16q          
            
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

code1001    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     sub_jmp_tab,A0    * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #7,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #13,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
            
code1010    STOP    #$2700
code1011    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     cmp_jmp_tab,A0    * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #7,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #13,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift left 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS

code1100    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     and_jmp_tab,A0    * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #7,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #13,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
code1101    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     add_jmp_tab,A0    * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #7,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #13,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift right 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
code1110    
            MOVEM.L     D0-D7/A0-A1/A3-A6, -(SP)     
            LEA     reg_mem_jum_tab,A0 * Index into the table
            CLR.L   D0                * Zero it
            MOVE.W  D7,D0             * Put instruction into D0
            MOVE.B  #8,D1             * Put shift constant into D1
            LSL.W   D1,D0             * Logical shift left 7 bits
        
            MOVE.B  #14,D1            * Put shift constant into D1
            LSR.W   D1,D0             * Logical shift left 13 bits
            
            MULU    #6,D0             * Multiply D0 by 6
                                      * Scale up 6 base on size of each jump entry
            JSR     0(A0,D0)          * Jump indirect with index
                                      * JSR stores the return location into the stack
                                      * so the 68k can return back to the JSR, and continue
            MOVEM.L     (SP)+, D0-D7/A0-A1/A3-A6
            RTS
            
code1111    STOP    #$2700
        
* System equates
stack       EQU     $A000
shift       EQU     12                * Shift 12 bits
CR          EQU     $0D
LF          EQU     $0A
EA_SOURCE   DS.B    1
EA_DEST     DS.B    1
ADDR_BUFFER DS.L    1
START_ADDR  DS.L    1
END_ADDR    DS.L    1
BUFFER      DS.B    128
WELCOME     DC.B    'Welcome to the disassembler!',CR,LF,0
PROMPTST    DC.B    'Enter starting address in hex:',CR,LF,0
PROMPTEND   DC.B    'Enter ending address in hex:',CR,LF,0
INVALID_MSG DC.B    'Invalid input!',CR,LF,0
MOVE_B      DC.B    'MOVE.B',CR,LF,0   
MOVE_W      DC.B    'MOVE.W',CR,LF,0  
MOVE_L      DC.B    'MOVE.L',CR,LF,0    
ADD_B       DC.B    'ADD.B',CR,LF,0 
ADD_W       DC.B    'ADD.W',CR,LF,0 
ADD_L       DC.B    'ADD.L',CR,LF,0 
ADDI_B      DC.B    'ADDI.B',CR,LF,0 
ADDI_W      DC.B    'ADDI.W',CR,LF,0 
ADDI_L      DC.B    'ADDI.L',CR,LF,0 
SUB_B       DC.B    'SUB.B',CR,LF,0 
SUB_W       DC.B    'SUB.W',CR,LF,0 
SUB_L       DC.B    'SUB.L',CR,LF,0 
ADDA_W      DC.B    'ADDA.W',CR,LF,0 
ADDA_L      DC.B    'ADDA.L',CR,LF,0 
CMP_B       DC.B    'CMP.B',CR,LF,0 
CMP_W       DC.B    'CMP.W',CR,LF,0 
CMP_L       DC.B    'CMP.L',CR,LF,0 
MOVEQ       DC.B    'MOVEQ',CR,LF,0 
BCC         DC.B    'BCC',CR,LF,0
BGT         DC.B    'BGT',CR,LF,0
BLE         DC.B    'BLE',CR,LF,0
DIVU        DC.B    'DIVU',CR,LF,0
AND_B       DC.B    'AND.B',CR,LF,0 
AND_W       DC.B    'AND.W',CR,LF,0 
AND_L       DC.B    'AND.L',CR,LF,0 
MULS_W      DC.B    'MULS.W',CR,LF,0 
ASR_B       DC.B    'ASR.B',CR,LF,0 
ASR_W       DC.B    'ASR.W',CR,LF,0 
ASR_L       DC.B    'ASR.L',CR,LF,0 
ASR         DC.B    'ASR',CR,LF,0 
LSL_B       DC.B    'LSL.B',CR,LF,0 
LSL_W       DC.B    'LSL.W',CR,LF,0 
LSL_L       DC.B    'LSL.L',CR,LF,0 
LSL         DC.B    'LSL',CR,LF,0 
ROL_B       DC.B    'ROL.B',CR,LF,0 
ROL_W       DC.B    'ROL.W',CR,LF,0 
ROL_L       DC.B    'ROL.L',CR,LF,0 
ROL         DC.B    'ROL',CR,LF,0 
CLR_B       DC.B    'CLR.B',CR,LF,0 
CLR_W       DC.B    'CLR.W',CR,LF,0 
CLR_L       DC.B    'CLR.L',CR,LF,0 
MOVEM_W     DC.B    'MOVEM.W',CR,LF,0 
MOVEM_L     DC.B    'MOVEM.L',CR,LF,0 
LEA         DC.B    'LEA',CR,LF,0
JSR         DC.B    'JSR',CR,LF,0
RTS         DC.B    'RTS',CR,LF,0
NOP         DC.B    'NOP',CR,LF,0
TEST        DC.B    'Bit manipulation/MOVEP/Immediate',CR,LF,0
            END    START        ; last line of source







